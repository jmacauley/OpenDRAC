/**
 * <pre>
 * The owner of the original code is Ciena Corporation.
 *
 * Portions created by the original owner are Copyright (C) 2004-2010
 * the original owner. All Rights Reserved.
 *
 * Portions created by other contributors are Copyright (C) the contributor.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   (Contributors insert name & email here)
 *
 * This file is part of DRAC (Dynamic Resource Allocation Controller).
 *
 * DRAC is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DRAC is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 * </pre>
 */

package com.nortel.appcore.app.drac.server.neproxy.mediation.tl1client.protocol.tl1.engine;

import com.nortel.appcore.app.drac.server.neproxy.mediation.tl1client.protocol.tl1.Response;
import com.nortel.appcore.app.drac.server.neproxy.mediation.tl1client.protocol.tl1.ResponseListener;
import com.nortel.appcore.app.drac.server.neproxy.mediation.tl1client.protocol.tl1.TL1Constants;

/**
 * ResponseNotifier is a wrapper class for ResponseListener. It hides
 * notification and other listener-specific data and behaviour from
 * MessageDispatcher. </p> ResponseNotifier has a correlation tag and response
 * listener, helping the dispatcher store and later find a specific listener
 * when a message must be delivered. Response notifier also manages the timeout
 * length and actual expiry timestamp for responses. This expiry timestamp is
 * used by ResponseTimer to trigger timeout notifications. </p></p> Most
 * importantly, ResponseNotifier does the actual work of notification. When an
 * acknowledgement, output response message, timeout or error is detected (in
 * their various ways), a corresponding Response object is placed on the
 * dispatcher's message queue. The notification thread will take that Response
 * and send runDelivery() to the notifier.</p></p> For the convenience of
 * listeners, response notifier stores the command code of its command. It also
 * keeps the acknowledgement code if an acknowledgement was received. Response
 * notifier will set these fields on all received response pieces, so that this
 * data is always available to listeners. </p></p> @see ReportNotifier @see
 * MessageDispatcher @see ResponseTimer
 */
final class ResponseNotifier {
	/**
	 * The command code of the notifier's command. This is not included in output
	 * response messages, so it is cached here for the convenience of listeners.
	 */
	private final String command;

	/**
	 * The correlation tag of the notifier's command. This is generated by the
	 * dispatcher when sending. It is used by the dispatcher to match output
	 * response messages to interested notifiers.
	 */
	private final String correlationTag;

	/**
	 * The listener that should be notified of any messages (or lack thereof, ie.
	 * timeouts) received from the network that were generated by the notifier's
	 * command.
	 */
	private final ResponseListener listener;

	/** The timeout period (in seconds) for this reply. */
	private int timeout;

	/** The system time (in milliseconds) at which the reply will time out. */
	private long expiryTime;

	/**
	 * Acknowledgment codes only appear in acknowledgments; this field is
	 * initialized from the acknowledgement (confusingly represented by a
	 * Response) and cached here for the convenience of listeners.
	 */
	protected String acknowledgementCode;

	/**
	 * Create and initialize a ResponseNotifier. @param listener The object that
	 * should be notified of any acknowlegdments, output response messages,
	 * botched messages, or timeouts. Stored as a convenience to
	 * MessageDispatcher. @param command The command code of the command that was
	 * sent when the notifier was created. Stored as a convenience to listeners. @param
	 * ctag The correlation tag that was generated for the notifier's command.
	 * Stored as a convenience to MessageDispatcher.
	 */
	public ResponseNotifier(ResponseListener listener, String command,
	    String ctag, int newTimeout) {
		this.listener = listener;
		this.command = command;
		correlationTag = ctag;
		setTimeout(newTimeout);
	}

	/**
	 * Create and return an object that can be used to represent a timeout on
	 * MessageDispatcher's message queue.
	 */
	public Response createTimeout() {
		Response result = new Response(correlationTag, true);
		result.setCommand(command);
		return result;
	}

	/**
	 * Return the system time (in millisecondsd) after which a timeout
	 * notification should be sent to the listener. This method is intended for
	 * the use of ResponseTimer. @see ResponseTimer
	 */
	public long getExpiryTime() {
		return expiryTime;
	}

	/**
	 * Reset the notifier's expiry time. This is intended for the use of the
	 * ResponseTimer, whenever an acknowledgement or output response message piece
	 * is received, but further messages are expected.
	 * 
	 * @see ResponseTimer
	 */
	public void resetTimeout() {
		expiryTime = System.currentTimeMillis() + timeout * 1000;
	}

	/**
	 * Decide where listener notification should execute. If it should execute in
	 * the notification thread, directly deliver the response; otherwise, post a
	 * runnable to the s wing event queue that will deliver the response later.
	 * This method is called directly by the MessageDispatcher notification
	 * thread.
	 */
	public void runDelivery(Response response) {
		deliver(response);
	}

	/**
	 * Notify my listener of the specified response, which may represent an
	 * acknowledgement, output response message, timeout, or parse failure.
	 * </p></p>
	 */
	void deliver(Response response) {
		// MessageDispatcher.logDebug("DELIVERING\n" + response + " " + listener);
		// if this is an ack, there are 2 cases where we shouldn't deliver
		boolean deliver = true;

		if (response.isAcknowledged()) {
			// responses that have ack codes at this point are acknowledgments
			acknowledgementCode = response.getAcknowledgmentCode();
			// don't deliver the ack if it is IP or PF
			deliver = !(// acknowledgementCode.equals(TL1Constants.IN_PROGRESS) ||
			acknowledgementCode.equals(TL1Constants.OK) || acknowledgementCode
			    .equals(TL1Constants.PRINTOUT_FOLLOWS));
		}
		else {
			response.setAcknowledgementCode(acknowledgementCode);
		}

		response.setCommand(command);

		if (response.isTimeout()) {
			// listener.timedOut(response);
			deliverTimeout(response);
		}
		else if (deliver) {
			listener.received(response);
		}
	}

	/**
	 * Deliver a timeout to the listener
	 */
	void deliverTimeout(Response message) {
		// notify the listener that this command has timedout
		//
		listener.timedOut(message);
	}

	/**
	 * Set the timeout period for this response (in seconds).
	 */
	private void setTimeout(int timeout) {
		this.timeout = timeout;
		expiryTime = System.currentTimeMillis() + timeout * 1000;
	}
}
