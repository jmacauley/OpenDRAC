/**
 * <pre>
 * The owner of the original code is Ciena Corporation.
 *
 * Portions created by the original owner are Copyright (C) 2004-2010
 * the original owner. All Rights Reserved.
 *
 * Portions created by other contributors are Copyright (C) the contributor.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   (Contributors insert name & email here)
 *
 * This file is part of DRAC (Dynamic Resource Allocation Controller).
 *
 * DRAC is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DRAC is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 * </pre>
 */

/* Generated By:JavaCC: Do not edit this line. Gentl1Stub.java */

package genstub;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Gentl1Stub implements Gentl1StubConstants {
  static final class JJCalls {
    int arg;
    Token first;
    int gen;
    JJCalls next;
  }

  public static boolean lookingAhead = false;
  public static Token token, jj_nt;
  public static Gentl1StubTokenManager token_source;
  static String directory;
  static SimpleCharStream jj_input_stream;

  static String packageName;

  static PrintStream ps = null;

  static String SEM = ";";

  static String TAB = "    ";

  private static Map<String, Object> table = new Hashtable<String, Object>();

  private static final JJCalls[] jj_2_rtns = new JJCalls[5];

  private static int jj_endpos;

  private static java.util.Vector jj_expentries = new java.util.Vector();

  // The method for printTl1Wrapper

  private static int[] jj_expentry;

  private static int jj_gc = 0;

  private static int jj_gen;

  private static boolean jj_initialized_once = false;

  private static int jj_kind = -1;

  private static int jj_la;

  private static final int[] jj_la1 = new int[21];

  private static final int[] jj_la1_0 = { 0x80000, 0x20, 0x20, 0x2000000,
      0x1000000, 0x0, 0x960000, 0x80, 0x20, 0x20, 0x10000000, 0x4000020, 0x400,
      0x200, 0x200, 0x2000, 0x200, 0x2000, 0x2020, 0x400, 0x400, };

  private static final int[] jj_la1_1 = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0,
      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };

  private static int[] jj_lasttokens = new int[100];

  private static int jj_ntk;

  private static boolean jj_rescan = false;

  private static Token jj_scanpos, jj_lastpos;

  private static boolean jj_semLA;

  public Gentl1Stub(Gentl1StubTokenManager tm) {
    if (jj_initialized_once) {
      System.out
          .println("ERROR: Second call to constructor of static parser.  You must");
      System.out
          .println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

  public Gentl1Stub(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out
          .println("ERROR: Second call to constructor of static parser.  You must");
      System.out
          .println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new Gentl1StubTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

  public Gentl1Stub(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out
          .println("ERROR: Second call to constructor of static parser.  You must");
      System.out
          .println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new Gentl1StubTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

  public static void disable_tracing() {
  }

  public static void enable_tracing() {
  }

  public static String forParam(String name, boolean isOptional,
      String mediationLabel) {
    return "new Parameter(\"" + name + "\"," + isOptional + "," + "\""
        + mediationLabel + "\"" + ")";
  }

  public static ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[34];
    for (int i = 0; i < 34; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 21; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & 1 << j) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & 1 << j) != 0) {
            la1tokens[32 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 34; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[]) jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  public static void getAID() throws ParseException {
    Token t;
    jj_consume_token(ID);
    jj_consume_token(LABRACE);
    t = jj_consume_token(ID);
    jj_consume_token(RABRACE);
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      getAID2();
      break;
    default:
      jj_la1[12] = jj_gen;

    }
    table.put("AID1", t.image);
  }

  public static void getAID2() throws ParseException {
    Token t;
    jj_consume_token(ID);
    jj_consume_token(LABRACE);
    t = jj_consume_token(ID);
    jj_consume_token(RABRACE);
    table.put("AID2", t.image);
  }

  public static void getBLOCK(Block block) throws ParseException {
    Token t, v;

    List<Param> parameters = block.getParameters();
    Param param = new Param();
    if (jj_2_2(3)) {
      jj_consume_token(LSBRACE);
      jj_consume_token(ID);
      jj_consume_token(LABRACE);
      t = jj_consume_token(ID);
      param.isOptional = true;
      param.name = t.image;
      parameters.add(param);
      block.setPos(true);
      jj_consume_token(RABRACE);
      jj_consume_token(RSBRACE);
      getPOSPARAMETER(parameters);
    }
    else {
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case ID:
        jj_consume_token(ID);
        jj_consume_token(LABRACE);
        t = jj_consume_token(ID);
        param.isOptional = false;
        param.name = t.image;
        parameters.add(param);
        block.setPos(true);

        jj_consume_token(RABRACE);
        getPOSPARAMETER(parameters);
        break;
      case LSBRACE:
        jj_consume_token(LSBRACE);
        t = jj_consume_token(ID);
        block.setPos(false);
        param.name = t.image;
        jj_consume_token(EQUAL);
        jj_consume_token(LABRACE);
        v = jj_consume_token(ID);
        param.value = v.image;
        parameters.add(param);
        jj_consume_token(RABRACE);
        jj_consume_token(RSBRACE);
        getNAMEVALUE(parameters);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  public static void getBLOCKS() throws ParseException {
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case BLKSEP:
      getGBLOCK();
      getPAYLOADBLOCKS("I");
      break;
    default:
      jj_la1[13] = jj_gen;

    }
  }

  public static void getBLOCKSEP() throws ParseException {
    Token t;
    jj_consume_token(COMMA);
    jj_consume_token(BLOCKSEP);
    jj_consume_token(EQUAL);
    t = jj_consume_token(SPC);
    table.put("BLOCKSEP", t.image);

  }

  public static void getCOMMENTEND() throws ParseException {
    Token t;
    jj_consume_token(COMMA);
    jj_consume_token(COMMENTEND);
    jj_consume_token(EQUAL);
    t = jj_consume_token(SPC);
    table.put("COMMENTEND", t.image);

  }

  public static void getCOMMENTSTART() throws ParseException {
    Token t;
    jj_consume_token(COMMA);
    jj_consume_token(COMMENTSTART);
    jj_consume_token(EQUAL);
    t = jj_consume_token(SPC);
    table.put("COMMENTSTART", t.image);

  }

  public static void getCTAG() throws ParseException {
    Token t;
    jj_consume_token(LABRACE);
    t = jj_consume_token(ID);
    jj_consume_token(RABRACE);
    table.put("CTAG", t.image);
  }

  public static void getDescription() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    table.put("DESCRIPTION", t.image);

  }

  public static void getEMBED() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    getCOMMENTSTART();
    getCOMMENTEND();
    getBLOCKSEP();
    table.put("EMBEDDED", t.image);
  }

  public static void getGBLOCK() throws ParseException {
    Token t;
    jj_consume_token(BLKSEP);
    if (jj_2_5(2)) {
      Block gblock = new Block(false, false, 1);
      table.put("BLOCK" + gblock.getNumber() + "I", gblock);
      getBLOCK(gblock);
    }
    else {

    }
  }

  public static void getLastModifiedData() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(DESCRIPTION);
    jj_consume_token(EQUAL);
    getDescription();
    table.put("DATA", t.image);

  }

  public static void getModifier() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case SEP:
      jj_consume_token(SEP);
      getModifier2();
      break;
    default:
      jj_la1[7] = jj_gen;

    }
    jj_consume_token(BLKSEP);
    getTID();
    jj_consume_token(BLKSEP);
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case ID:
      getAID();
      break;
    default:
      jj_la1[8] = jj_gen;

    }
    jj_consume_token(BLKSEP);
    getCTAG();
    getBLOCKS();
    jj_consume_token(TERMINATOR);
    table.put("MOD1", t.image);
  }

  public static void getModifier2() throws ParseException {
    Token t;
    Token m;
    Token s, d;
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case ID:
      t = jj_consume_token(ID);
      table.put("MOD2", t.image);
      break;
    case CLBRACE:
      jj_consume_token(CLBRACE);
      m = jj_consume_token(ID);
      table.put("MOD2TYPE", m.image);
      jj_consume_token(EQUAL);
      Vector values = new Vector();
      label_3: while (true) {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
        case ID:

          break;
        default:
          jj_la1[9] = jj_gen;
          break label_3;
        }
        s = jj_consume_token(ID);
        values.add(s.image);
        jj_consume_token(COMMA);
      }
      table.put("MOD2VALUES", values);
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case LP:
        jj_consume_token(LP);
        d = jj_consume_token(ID);
        table.put("MOD2Default", d.image);
        jj_consume_token(RP);
        break;
      default:
        jj_la1[10] = jj_gen;

      }
      jj_consume_token(CRBRACE);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public static void getNAMEVALUE(List<Param> parameters) throws ParseException {
    Token t, v;
    Param param;
    int i = 1;
    label_6: while (true) {
      if (jj_2_3(2)) {

      }
      else {
        break label_6;
      }
      jj_consume_token(LSBRACE);
      jj_consume_token(COMMA);
      t = jj_consume_token(ID);
      param = new Param();
      param.name = t.image;

      jj_consume_token(EQUAL);
      jj_consume_token(LABRACE);
      v = jj_consume_token(ID);
      param.value = v.image;
      parameters.add(param);
      jj_consume_token(RABRACE);
      jj_consume_token(RSBRACE);
    }
  }

  // Following methods are for TL1Wrapper
  public static void getNEType() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(VERSION);
    jj_consume_token(EQUAL);
    getVersion();
    table.put("NE", t.image);

  }

  public static Token getNextToken() {
    if (token.next != null) {
      token = token.next;
    }
    else {
      token = token.next = token_source.getNextToken();
    }
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  public static void getPAYLOADBLOCKS(String type) throws ParseException {
    Token t;
    int number = 1;
    label_4: while (true) {
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case BLKSEP:

        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
      jj_consume_token(BLKSEP);
      Block block = new Block(false, false, ++number);
      table.put("BLOCK" + number + type, block);
      getBLOCK(block);
    }
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case LSBRACE:
      jj_consume_token(LSBRACE);
      jj_consume_token(BLKSEP);
      Block block = new Block(true, false, ++number);

      table.put("BLOCK" + number + type, block);
      getBLOCK(block);
      jj_consume_token(RSBRACE);
      break;
    default:
      jj_la1[15] = jj_gen;

    }
  }

  public static void getPOSPARAMETER(List<Param> parameters)
      throws ParseException {
    Token t;
    Param param;
    label_7: while (true) {
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case COMMA:

        break;
      default:
        jj_la1[19] = jj_gen;
        break label_7;
      }
      if (jj_2_4(2)) {
        jj_consume_token(COMMA);
        jj_consume_token(LSBRACE);
        jj_consume_token(ID);
        jj_consume_token(LABRACE);
        t = jj_consume_token(ID);
        param = new Param();
        param.isOptional = true;
        param.name = t.image;
        parameters.add(param);
        jj_consume_token(RABRACE);
        jj_consume_token(RSBRACE);
      }
      else {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          jj_consume_token(ID);
          jj_consume_token(LABRACE);
          t = jj_consume_token(ID);
          param = new Param();
          param.isOptional = false;
          param.name = t.image;
          parameters.add(param);
          jj_consume_token(RABRACE);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  public static void getRESPPAYLOADBLOCKS(String type) throws ParseException {
    Token t;
    int number = 1;
    label_5: while (true) {
      if (jj_2_1(2)) {

      }
      else {
        break label_5;
      }
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case BLKSEP:
        jj_consume_token(BLKSEP);
        break;
      default:
        jj_la1[16] = jj_gen;

      }
      Block block = new Block(false, false, ++number);

      table.put("BLOCK" + number + type, block);
      getBLOCK(block);
    }
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case LSBRACE:
      jj_consume_token(LSBRACE);
      jj_consume_token(BLKSEP);
      Block block = new Block(true, false, ++number);

      table.put("BLOCK" + number + type, block);
      getBLOCK(block);
      jj_consume_token(RSBRACE);
      break;
    default:
      jj_la1[17] = jj_gen;
    }
  }

  public static void getTID() throws ParseException {
    Token t;
    jj_consume_token(LSBRACE);
    jj_consume_token(LABRACE);
    t = jj_consume_token(ID);
    table.put("TID", t.image);
    jj_consume_token(RABRACE);
    jj_consume_token(RSBRACE);
  }

  public static Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) {
        t = t.next;
      }
      else {
        t = t.next = token_source.getNextToken();
      }
    }
    return t;
  }

  public static void getTotalCommandsNumber() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(DATA);
    jj_consume_token(EQUAL);
    getLastModifiedData();
    table.put("NUMBER", t.image);
  }

  public static void getUNPRNTABLE() throws ParseException {
    Token t;
    table.put("UNPRNTABLE", "TRUE");
  }

  public static void getVerb() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    jj_consume_token(SEP);
    getModifier();
    table.put("VERB", t.image);
  }

  public static void getVersion() throws ParseException {
    Token t;
    t = jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(NUMBER);
    jj_consume_token(EQUAL);
    getTotalCommandsNumber();
    table.put("VERSION", t.image);
  }

  public static void Input() throws ParseException {
    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
    case TL1WRAPPER:
      jj_consume_token(TL1WRAPPER);
      jj_consume_token(BLKSEP);
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case NE:
        jj_consume_token(NE);
        jj_consume_token(EQUAL);
        getNEType();
        break;
      default:
        jj_la1[0] = jj_gen;

      }
      break;
    case VERSION:
      jj_consume_token(VERSION);
      jj_consume_token(EQUAL);
      label_1: while (true) {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
        case ID:

          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        jj_consume_token(ID);
      }
      break;
    case DESCRIPTION:
      jj_consume_token(DESCRIPTION);
      jj_consume_token(EQUAL);
      label_2: while (true) {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
        case ID:

          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(ID);
      }
      break;
    case CMD:
      jj_consume_token(CMD);
      jj_consume_token(EQUAL);
      getVerb();
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case EMBED:
        jj_consume_token(EMBED);
        jj_consume_token(EQUAL);
        getEMBED();
        break;
      default:
        jj_la1[3] = jj_gen;

      }
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case RESP:
        jj_consume_token(RESP);
        jj_consume_token(EQUAL);
        getRESPPAYLOADBLOCKS("O");
        break;
      default:
        jj_la1[4] = jj_gen;

      }
      switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
      case UNPRNTABLE:
        jj_consume_token(UNPRNTABLE);
        getUNPRNTABLE();
        break;
      default:
        jj_la1[5] = jj_gen;

      }
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public static String inQuotes(Object o) {
    return "\"" + o + "\"";
  }

  public static void main(String args[]) throws ParseException {
    int processed = 0;
    try {
      int number = Integer.parseInt(getNumberOfCommands(new File(args[0])));
      InputStream in = new FileInputStream(new File(args[0]));
      directory = args[1];
      packageName = args[2];
      Gentl1Stub parser = new Gentl1Stub(in);

      for (int i = 0; i < number; i++) {
        parser.Input();
        printClass();
        parser.table.clear();
        processed++;
      }
    }
    catch (Exception e) {
      e.printStackTrace();
      System.out.println(e);
      System.out.println("Processed " + processed + " commands ");
      System.exit(-1);
    }
    System.out.println("\n Done Generating TL1 Stubs " + args[0] + " "
        + args[1] + " " + args[2]);
    // Note ANT expects a zero return code, else it considers a failure to have
    // occured.
    System.exit(0);
  }

  public static void print(String s) {
    ps.print(s);
  }

  public static void printClass() throws FileNotFoundException,
      SecurityException {
    File file = null;
    File dir = new File(directory);
    dir.mkdir();

    String NETYPE = (String) table.get("NE");
    if (NETYPE != null) {
      file = new File(directory + "/TL1Wrapper.java");
      printTl1Wrapper((String) table.get("NE"), (String) table.get("VERSION"),
          (String) table.get("NUMBER"), (String) table.get("DATA"),
          (String) table.get("DESCRIPTION"), file);
    }

    String VERB = (String) table.get("VERB");
    if (VERB == null) {
      return;
    }
    String MOD1 = (String) table.get("MOD1");
    String MOD2 = null;
    if (!table.containsKey("MOD2")) {
      if (table.containsKey("MOD2TYPE")) {
        printClassWithMod2Enumerated(VERB, MOD1);
      }
      else {
        file = new File(directory + "/" + VERB + "_" + MOD1 + ".java");
        printClassStructure(VERB, MOD1, MOD2, file);
      }
    }
    else {
      MOD2 = (String) table.get("MOD2");
      file = new File(directory + "/" + VERB + "_" + MOD1 + "_" + MOD2
          + ".java");
      printClassStructure(VERB, MOD1, MOD2, file);

    }

  }

  public static void printClassStructure(String VERB, String MOD1, String MOD2,
      File file) throws FileNotFoundException {
    ps = new PrintStream(new FileOutputStream(file));
    println("package " + packageName + ";");
    println("import com.nortel.appcore.app.drac.server.neproxy.mediation.tl1wrapper.*;");
    println("");
    if (MOD2 == null) {
      println("public class " + VERB + "_" + MOD1);
    }
    else {
      println("public class " + VERB + "_" + MOD1 + "_" + MOD2);
    }
    println("{"); // Beginning of class
    println(TAB + "public static final boolean  isMOD2Required = "
        + table.containsKey("MOD2") + SEM);
    println(TAB + "public static final boolean isMOD2Enumerated = "
        + table.containsKey("MOD2TYPE") + SEM);
    if (table.containsKey("UNPRNTABLE")) {
      println(TAB + "public static final boolean isUnprintable =" + "true"
          + SEM);
    }
    else {
      println(TAB + "public static final boolean isUnprintable =" + "false"
          + SEM);
    }

    if (table.containsKey("MOD2TYPE")) {
      println(TAB + "public static String MOD2Name = "
          + inQuotes(table.get("MOD2TYPE")) + SEM);
      Vector modValues = (Vector) table.get("MOD2VALUES");
      Iterator itr = modValues.iterator();
      println(TAB + "public static String [] mod2Values= {");
      String mod2v = (String) itr.next();
      println(TAB + TAB + inQuotes(mod2v));
      while (itr.hasNext()) {
        mod2v = (String) itr.next();
        println(TAB + TAB + "," + inQuotes(mod2v));
      }
      println(TAB + "}" + SEM);

      println(TAB + "public static String MOD2Def = "
          + inQuotes(table.get("MOD2Default")) + SEM);
    }
    println(TAB + "public static final boolean isTIDRequired = " + "true" + SEM);

    if (table.containsKey("EMBEDDED")) {
      println(TAB + "public static final String EmbeddedType = "
          + inQuotes(table.get("EMBEDDED")) + SEM);
      println(TAB + "public static final String commentStart = "
          + inQuotes(table.get("COMMENTSTART")) + SEM);
      println(TAB + "public static final String commentEnd = "
          + inQuotes(table.get("COMMENTEND")) + SEM);
      println(TAB + "public static final String blockSep = "
          + inQuotes(table.get("BLOCKSEP")) + SEM);
      println(TAB + "public static final boolean isEmbedded = "
          + table.containsKey("EMBEDDED") + SEM);
    }
    else {
      println(TAB + "public static final String EmbeddedType = "
          + inQuotes("NONE") + SEM);
    }
    println("");
    // AIDS

    println(TAB + "public static final String AID [] =  {");
    if (table.containsKey("AID1")) {
      println(TAB + "                              "
          + inQuotes(table.get("AID1")));
    }
    if (table.containsKey("AID2")) {
      println(TAB + "                              " + ","
          + inQuotes(table.get("AID2")));
    }
    println(TAB + " }" + SEM);

    println(TAB + "public static final String CTAG = "
        + inQuotes(table.get("CTAG")) + SEM);

    String Input = "I";
    // Printing GBLOCK
    println("");

    println(TAB + "public static final boolean  isGBlockPresent = "
        + table.containsKey("BLOCK1" + Input) + SEM);
    if (table.containsKey("BLOCK1" + Input)) {
      Block block = (Block) table.get("BLOCK1" + Input);
      List<Param> parameters = block.getParameters();
      println(TAB + "public static final boolean G_Block_Is_Pos = "
          + block.isPos() + SEM);
      Iterator itr = parameters.iterator();
      println(TAB + "public static Parameter[]  G_BLOCK= {");
      while (itr.hasNext()) {
        Param param = (Param) itr.next();
        if (block.isPos()) {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.name));
        }
        else {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.value));
        }
        if (itr.hasNext()) {
          println(",");
        }
        else {
          println("");
        }
      }
      println(TAB + "}" + SEM);
    }

    // Printing FBLOCKS
    println(TAB + "public static Parameter[][]  F_BLOCKS= {");

    int i = 2;
    Vector fblocks = new Vector();

    while (table.containsKey("BLOCK" + i + Input)) {
      if (i != 2) {
        println(",");
      }
      Block block = (Block) table.get("BLOCK" + i + Input);
      fblocks.add("" + block.isPos());
      println(TAB + TAB + "{");
      List<Param> parameters = block.getParameters();
      Iterator itr = parameters.iterator();

      while (itr.hasNext()) {
        Param param = (Param) itr.next();

        if (block.isPos()) {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.name));
        }
        else {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.value));
        }
        if (itr.hasNext()) {
          println(",");
        }
        else {
          println("");
        }
      }
      i++;
      print(TAB + TAB + "}");
    }
    println(TAB + "}" + SEM);
    println(TAB + "public static final boolean  []F_Block_Is_Pos =  {");
    for (int m = 0; m < fblocks.size(); m++) {
      print(TAB + TAB + fblocks.elementAt(m));
      if (m != fblocks.size() - 1) {
        println(",");
      }
      else {
        println("");
      }

    }
    println(TAB + "}" + SEM);

    // Printing FBLOCKS
    println(TAB + "public static Parameter[][]  R_BLOCKS= {");

    i = 2;
    String Output = "O";
    Vector rblocks = new Vector();

    while (table.containsKey("BLOCK" + i + Output)) {
      if (i != 2) {
        println(",");
      }
      Block block = (Block) table.get("BLOCK" + i + Output);
      rblocks.add("" + block.isPos());
      println(TAB + TAB + "{");
      List<Param> parameters = block.getParameters();
      Iterator itr = parameters.iterator();

      while (itr.hasNext()) {
        Param param = (Param) itr.next();
        if (block.isPos()) {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.name));
        }
        else {
          print(TAB + TAB + forParam(param.name, param.isOptional, param.value));
        }
        if (itr.hasNext()) {
          println(",");
        }
        else {
          println("");
        }
      }
      i++;
      print(TAB + TAB + "}");
    }
    println(TAB + "}" + SEM);
    println(TAB + "public static final boolean  []R_Block_Is_Pos =  {");
    for (int m = 0; m < rblocks.size(); m++) {
      print(TAB + TAB + rblocks.elementAt(m));
      if (m != rblocks.size() - 1) {
        println(",");
      }
      else {
        println("");
      }

    }
    println(TAB + "}" + SEM);

    if (table.containsKey("DBCHG")) {
      println(TAB + "public static final boolean  isDBCHG = "
          + table.containsKey("DBCHG") + SEM);
    }
    println("}");// End of Class
    ps.close();

  }

  public static void printClassWithMod2Enumerated(String VERB, String MOD1)
      throws FileNotFoundException {

    if (table.containsKey("MOD2TYPE")) {

      File file = new File(directory + "/" + VERB + "_" + MOD1 + ".java");
      printClassStructure(VERB, MOD1, null, file);
      Vector modValues = (Vector) table.get("MOD2VALUES");
      Iterator itr = modValues.iterator();
      while (itr.hasNext()) {
        String MOD2 = (String) itr.next();

        file = new File(directory + "/" + VERB + "_" + MOD1 + "_" + MOD2
            + ".java");
        printClassStructure(VERB, MOD1, MOD2, file);
      }

    }
  }

  public static void println(String s) {
    ps.println(s);
  }

  public static void printTl1Wrapper(String ne, String version, String number,
      String data, String desc, File file) throws FileNotFoundException {
    ps = new PrintStream(new FileOutputStream(file));
    println("package " + packageName + ";");
    println("");
    println("public class TL1Wrapper");
    println("{");
    println(TAB + "public static String NETYPE = " + inQuotes(table.get("NE"))
        + SEM);
    println(TAB + "public static String VERSION = "
        + inQuotes(table.get("VERSION")) + SEM);
    println(TAB + "public static String TOTALCOMMANDSNUMBER = "
        + inQuotes(table.get("NUMBER")) + SEM);
    println(TAB + "public static String LASTMODIFIEDDATA = "
        + inQuotes(table.get("DATA")) + SEM);
    println(TAB + "public static String DESCRIPTION = "
        + inQuotes(table.get("DESCRIPTION")) + SEM);
    println("}");

  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

  private static String getNumberOfCommands(File file) {
    try {
      BufferedReader reader = new BufferedReader(new FileReader(file));
      Pattern pattern = Pattern.compile("#TOTALCOMMANDSNUMBER");
      String line = null;

      while ((line = reader.readLine()) != null) {
        Matcher matcher = pattern.matcher(line);

        if (matcher.find()) {
          StringTokenizer tokenizer = new StringTokenizer(line, ",");

          while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();

            Matcher currentMatcher = pattern.matcher(token);

            if (currentMatcher.find()) {
              StringTokenizer currentTokenizer = new StringTokenizer(token, "=");

              for (int i = 0; currentTokenizer.hasMoreTokens(); i++) {
                String currentToken = currentTokenizer.nextToken();
                if (i == 1) {
                  return currentToken;
                }
              }
            }
          }
        }
      }
    }
    catch (Exception e) {
      System.out.println("Error Getting Number of Commands: " + e.getClass()
          + e.getLocalizedMessage());
    }
    return "1000";
  }

  private static boolean jj_2_1(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  private static boolean jj_2_2(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  private static boolean jj_2_3(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  private static boolean jj_2_4(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  private static boolean jj_2_5(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  private static boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_8()) {
      jj_scanpos = xsp;
    }
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_3R_9()) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3_2() {
    if (jj_scan_token(LSBRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(ID)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(LABRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3_3() {
    if (jj_scan_token(LSBRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(COMMA)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3_4() {
    if (jj_scan_token(COMMA)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(LSBRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3_5() {
    if (jj_3R_9()) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3R_10() {
    if (jj_scan_token(ID)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(LABRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3R_11() {
    if (jj_scan_token(LSBRACE)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    if (jj_scan_token(ID)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3R_8() {
    if (jj_scan_token(BLKSEP)) {
      return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
      jj_scanpos = xsp;
      if (jj_3R_10()) {
        jj_scanpos = xsp;
        if (jj_3R_11()) {
          return true;
        }
        if (jj_la == 0 && jj_scanpos == jj_lastpos) {
          return false;
        }
      }
      else if (jj_la == 0 && jj_scanpos == jj_lastpos) {
        return false;
      }
    }
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) {
      return false;
    }
    return false;
  }

  private static void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) {
      return;
    }
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    }
    else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration ee = jj_expentries.elements(); ee
          .hasMoreElements();) {
        int[] oldentry = (int[]) ee.nextElement();
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) {
            break;
          }
        }
      }
      if (!exists) {
        jj_expentries.addElement(jj_expentry);
      }
      if (pos != 0) {
        jj_lasttokens[(jj_endpos = pos) - 1] = kind;
      }
    }
  }

  private static Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) {
      token = token.next;
    }
    else {
      token = token.next = token_source.getNextToken();
    }
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (JJCalls c : jj_2_rtns) {
          while (c != null) {
            if (c.gen < jj_gen) {
              c.first = null;
            }
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  private static int jj_ntk() {
    if ((jj_nt = token.next) == null) {
      return jj_ntk = (token.next = token_source.getNextToken()).kind;
    }
    return jj_ntk = jj_nt.kind;
  }

  private static void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg;
          jj_lastpos = jj_scanpos = p.first;
          switch (i) {
          case 0:
            jj_3_1();
            break;
          case 1:
            jj_3_2();
            break;
          case 2:
            jj_3_3();
            break;
          case 3:
            jj_3_4();
            break;
          case 4:
            jj_3_5();
            break;
          }
        }
        p = p.next;
      }
      while (p != null);
    }
    jj_rescan = false;
  }

  private static void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) {
        p = p.next = new JJCalls();
        break;
      }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la;
    p.first = token;
    p.arg = xla;
  }

  private static boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      }
      else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    }
    else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0;
      Token tok = token;
      while (tok != null && tok != jj_scanpos) {
        i++;
        tok = tok.next;
      }
      if (tok != null) {
        jj_add_error_token(kind, i);
      }
    }
    return jj_scanpos.kind != kind;
  }

  public void ReInit(Gentl1StubTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) {
      jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
      jj_2_rtns[i] = new JJCalls();
    }
  }

}

class Block {
  private final boolean isOptional;
  private boolean isPos;
  private final int number;
  private final List<Param> parameters = new ArrayList<Param>();

  public Block(boolean optional, boolean pos, int num) {
    isOptional = optional;
    isPos = pos;
    number = num;
  }

  @Override
  public String toString() {
    return " optional:" + isOptional + " isPos " + isPos + " num: " + number
        + " parms: " + parameters;
  }

  /**
   * @return the number
   */
  int getNumber() {
    return number;
  }

  /**
   * @return the parameters
   */
  List<Param> getParameters() {
    return parameters;
  }

  /**
   * @return the isPos
   */
  boolean isPos() {
    return isPos;
  }

  /**
   * @param isPos
   *          the isPos to set
   */
  void setPos(boolean isPos) {
    this.isPos = isPos;
  }
}

class Param {
  boolean isOptional;
  String name;
  String value;

  @Override
  public String toString() {
    return " name:" + name + " value:" + value + " optional:" + isOptional;
  }
}
