/**
 * <pre>
 * The owner of the original code is Ciena Corporation.
 *
 * Portions created by the original owner are Copyright (C) 2004-2010
 * the original owner. All Rights Reserved.
 *
 * Portions created by other contributors are Copyright (C) the contributor.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   (Contributors insert name & email here)
 *
 * This file is part of DRAC (Dynamic Resource Allocation Controller).
 *
 * DRAC is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DRAC is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 * </pre>
 */

package com.nortel.appcore.app.drac.server.lpcp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jdom2.Element;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nortel.appcore.app.drac.common.FacilityConstants;
import com.nortel.appcore.app.drac.common.db.DbKeys.NetworkElementConnectionCols;
import com.nortel.appcore.app.drac.common.graph.DracVertex;
import com.nortel.appcore.app.drac.common.graph.NeStatus;
import com.nortel.appcore.app.drac.common.types.CrossConnection;
import com.nortel.appcore.app.drac.common.types.OperationType;
import com.nortel.appcore.app.drac.common.utility.GenericJdomParser;
import com.nortel.appcore.app.drac.common.utility.NetworkElementEventXML;
import com.nortel.appcore.app.drac.server.lpcp.routing.HierarchicalModel;
import com.nortel.appcore.app.drac.server.lpcp.routing.TopologyManager;
import com.nortel.appcore.app.drac.server.lpcp.trackers.LpcpFacility;
import com.nortel.appcore.app.drac.server.nrb.LpcpEvent;
import com.nortel.appcore.app.drac.server.nrb.LpcpEvent.LpcpEventType;

/**
 * This class is concerned with processing events from NeProxy and forward
 * events to the admin console
 *
 * @since Nov 2010
 * @author pitman
 */
public final class LpcpEventHandler {
  private final Logger log = LoggerFactory.getLogger(getClass());

	private static final String TID_ATTR = "tid";
	private static final String IP_ATTR = "ip";
	private static final String PORT_ATTR = "port";
	private static final String MODE_ATTR = "mode";
	private static final String NAME_ATTR = "name";
	private static final String DATA_ATTR = "data";
	private static final String VALUE_ATTR = "value";
	private static final String AID_ATTR = "aid";
	private static final String STATE_ATTR = "state";
	private static final String NOTIFTYPE_ATTR = "notificationType";
	private static final String EVT_ASSOCIATION = "association";
	private static final String EVT_DBCHANGE = "dbchange";
	private static final String EVENTINFO_NODE = "eventInfo";
	private static final String EVTNOTIF_XCON = "connection";
	private static final String EVTNOTIF_FAC = "facility";
	private static final String EVTNOTIF_ADJ = "adjacency";
	private static final String EVTNOTIF_DOC = "docStatus";
	private static final String NE_EVENT_NAME = "NetworkElementEvent";
	private static final String EVENT_NAME = "event";
	private static final String NODE_NAME = "node";
	private static final String DATA_NODE = "data";
	private static final String ELEMENT_NODE = "element";
	private static final String NEID_ATTR = "id";

	private static LpcpEventHandler instance;
	private final TopologyManager topologyMgr;
	private final DiscoveryManager discoveryMgr;
	private final Lpcp lpcp;

	private LpcpEventHandler(Lpcp theLpcp) {
		lpcp = theLpcp;
		topologyMgr = lpcp.getTopologyMgr();
		discoveryMgr = lpcp.getDiscoveryMgr();
	}

	public static synchronized LpcpEventHandler getInstance(Lpcp lpcp) {
		if (instance != null) {
			return instance;
		}
		instance = new LpcpEventHandler(lpcp);
		return instance;
	}

	/**
	 * Events generated by the NeProxy get delivered here (via a indirect route)
	 */
	public synchronized void handleCallback(Map<String, Object> event) {
		try {

			processEvent(event);
		}
		catch (Exception e) {
			log.error("Lpcp::handleCallback exception", e);
		}
	}

	/**
	 * The lpcp routing graph has changed, tell the admin client to refresh
	 * itself. No extra data required.
	 */
	public void notifyClientsGraphRefreshRequired() {
		log.debug("notifyClientsGraphRefreshRequired ");
		notifyClients(new LpcpEvent(LpcpEventType.GRAPH_REFRESH_REQUIRED, null));
	}


	private HierarchicalModel getModelMgr() {
		return lpcp.getModelMgr();
	}

	private synchronized void notifyClients(LpcpEvent event) {
		try {
			LpcpEventServer.INSTANCE.publishEvent(event);
		}
		catch (Exception e) {
			log.error("event publish failed for " + event, e);
		}
	}

	/**
	 * Layer 0 CPL status change event.
	 */
	private void notifyClientsDocEvent(Element element) {
		String e = new XMLOutputter().outputString(element);
		log.debug("notifyClientsDocEvent Detected DOC notification event " + e);
		notifyClients(new LpcpEvent(LpcpEventType.DOC_EVENT, e));
	}

	private void notifyClientsVertexUpdated(Map<String, Object> event,
	    Element element) {
		String e = new XMLOutputter().outputString(element);

		notifyClients(new LpcpEvent(LpcpEventType.VERTEX_UPDATED, e));
	}

	/**
	 * Process Association state change events from NeProxy
	 */
	private void processAssociationEvent(Element element) throws Exception {
		if (element == null) {
			log.error("processAssociationEvent provided with a corrupted event ");
			return;
		}

		NeStatus neStatus = NeStatus
		    .fromString(element.getAttributeValue("status"));
		String tid = element.getAttributeValue(TID_ATTR);
		String neid = element.getAttributeValue(NEID_ATTR);
		String ip = element.getAttributeValue(IP_ATTR);
		String port = element.getAttributeValue(PORT_ATTR);
		String mode = element.getAttributeValue(MODE_ATTR);

		/*
		 * GG ADJ Update the routing graph vertex status (regardless of whether or
		 * not a new graph was consolidated) and notify listeners
		 */
		DracVertex v = topologyMgr.getVertex(neid);
		if (v != null) {
			v.setStatus(neStatus);
			v.setMode(mode);
			// notifyClients(topologyMgr.buildVertexStateEvent(v));
		}

		// Detected NE aligned event
		if (NeStatus.NE_ALIGNED.equals(neStatus)) {
			log.debug("Detected network element aligned event");

			/* We should (re)discover all of the NE's attributes. */
			log.debug("Creating DiscoverThread object for: " + neid + "[" + tid + "]");
			DiscoverThread dt = new DiscoverThread(neid, tid, ip, port, topologyMgr,
			    getModelMgr());
			discoveryMgr.addToDiscoveryQ(dt);
		}
		else if (NeStatus.NE_NOT_CONNECT.equals(neStatus)) {
			log.debug("Detected network element notConnect event for: " + tid + " "
			    + neid + " " + ip + " " + port);

			// First, check whether the NE is already in our model
			if (topologyMgr.getVertex(neid) != null) {
				synchronized (getModelMgr()) {
					log.debug(tid + "(" + neid + ") "
					    + " - removing cached facilities...");
					getModelMgr().removeFacilitiesForNe(neid);
				}
			}
		}

		/*
		 * GG ADJ This is the only location in Lpcp in which we will be notified of
		 * NE adds/deletes. Will update the graph if topo changes are detected. We
		 * still need to update vertex states below (if the graph topo doesn't
		 * change).
		 */
		topologyMgr.requestConsolidation();
	}

	private void processConnectionEvent(String neId,
	    Map<String, String> dbchangeDetails) throws Exception {
		// String OP_ADD_KEY = "add";
		// String OP_DEL_KEY = "delete";
		// String OP_KEY = "operation";

		log.debug("Detected connection notification event");
		String operation = null;
		String targetXcAid = null;
		String sourceXcAid = null;
		String swmateXcAid = null;
		String rate = null;
		String provUnit = null;
		String actualUnit = null;
		String cktid = null;

		// String TARGET_KEY = "target";
		// String SOURCE_KEY = "source";
		// String RATE_KEY = "rate";
		// String PROVUNIT_KEY = "provUnit";
		// String ACTUNIT_KEY = "actualUnit";
		// String CKTID_KEY = "cktid";

		/**
		 * <pre>
		 *  Detected database change event:
		 *  <event name="dbchange" id="00-21-E1-D6-D6-70_null" owner="TDEFAULT_PROXY" time="1285083695021">
		 *  <eventInfo notificationType="connection" occurredDate="10-09-21" occurredTime="15-44-36" />
		 *  <data>
		 *  <element name="description" value="GEN_TL1_CMD" />
		 *  <element name="tChannel" value="1" />
		 *  <element name="sChannel" value="1" />
		 *  <element name="sPort" value="1" />
		 *  <element name="tSlot" value="5" />
		 *  <element name="tShelf" value="1" />
		 *  <element name="operation" value="add" />
		 *  <element name="sSlot" value="11" />
		 *  <element name="rate" value="STS1" />
		 *  <element name="swmate" value="" />
		 *  <element name="source" value="OC12-1-11-1-1" />
		 *  <element name="target" value="OC48-1-5-1-1" />
		 *  <element name="cktid" value="DRAC-cd28862f-1285083560732" />
		 *  <element name="tPort" value="1" />
		 *  <element name="sShelf" value="1" />
		 *  </data>
		 *  <node type="OME6" id="00-21-E1-D6-D6-70" ip="47.134.3.230"
		 *  port="10001" tid="OME0039" mode="SONET" status="aligned" /></event>
		 * </pre>
		 */
		// Parse all of the connection attributes:
		// Expecting:
		// <NetworkElementEvent>
		// <event name="dbchange" id="00-15-9B-FD-09-74_100017458"
		// time="1147380293522">
		// <data><element name="description" value="GEN_TL1_CMD" />
		// <element name="target" value="OC48-1-5-1-1" />
		// <element name="source" value="WAN-1-4-4-1" />
		// <element name="operation" value="add" />
		// <element name="rate" value="STS1" />
		// <element name="provUnit" value="1" /><element name="rate" value="STS1" />
		// <element name="actualUnit" value="0" />
		// </data>
		// <eventInfo notificationType="connection" occurredDate="06-05-11"
		// occurredTime="20-42-06" />
		// <node type="OME" id="00-15-9B-FD-09-74" ip="47.134.25.118" port="10001"
		// tid="OME0237"
		// mode="SDH"
		// status="N/A" />
		// </event>
		// <backslashNetworkElementEvent>

		for (Map.Entry<String, String> e : dbchangeDetails.entrySet()) {
			String key = e.getKey();
			String value = e.getValue();

			if (NetworkElementConnectionCols.TARGETAID.equals(key)) {
				targetXcAid = value;
			}
			if (NetworkElementConnectionCols.SOURCEAID.equals(key)) {
				sourceXcAid = value;
			}
			if (NetworkElementConnectionCols.SWMATEAID.equals(key)) {
				swmateXcAid = value;
			}
			if (NetworkElementEventXML.OPERATION_ATTR.equals(key)) {
				operation = value;
			}
			if (NetworkElementConnectionCols.RATE.equals(key)) {
				rate = value;
			}
			// if (PROVUNIT_KEY.equals(key))
			// {
			// provUnit = value;
			// }
			// if (ACTUNIT_KEY.equals(key))
			// {
			// actualUnit = value;
			// }
			if (NetworkElementConnectionCols.ID.equals(key)) {
				cktid = value;
			}
		}

		log.debug("Parsed connection event attributes: " + "target: " + targetXcAid
		    + " source: " + sourceXcAid + " operation: " + operation + " rate: "
		    + rate + " provUnit: " + provUnit + " actualUnit: " + actualUnit);

		if (targetXcAid == null || sourceXcAid == null || operation == null
		    || rate == null) {
			log.error("Unexpected null attribute detected in connection event dbchange report.  SKIPPING... target: "
                    + targetXcAid + " source: " + sourceXcAid + " operation: "
                    + operation + " rate: " + rate + " provUnit: " + provUnit
                    + " actualUnit: " + actualUnit);
			return;
		}

		// HACK!!! Argghh...
		// if (sourceXcAid.startsWith("WAN"))
		// {
		// sourceXcAid = Utility.convertWAN2ETH(sourceXcAid);
		// }
		// if (targetXcAid.startsWith("WAN"))
		// {
		// targetXcAid = Utility.convertWAN2ETH(targetXcAid);
		// }
		// if (swmateXcAid != null && swmateXcAid.startsWith("WAN"))
		// {
		// swmateXcAid = Utility.convertWAN2ETH(swmateXcAid);
		// }

		String sourceAid = sourceXcAid.substring(0, sourceXcAid.lastIndexOf('-'));
		String sourceChannel = sourceXcAid.substring(
		    sourceXcAid.lastIndexOf('-') + 1, sourceXcAid.length());
		String targetAid = targetXcAid.substring(0, targetXcAid.lastIndexOf('-'));
		String targetChannel = targetXcAid.substring(
		    targetXcAid.lastIndexOf('-') + 1, targetXcAid.length());
		String swmateAid = null;
		String swmateChannel = null;

		// int rateInt = Utility.convertStringRateToRateIdxInt(rate);

		int srcChannelInt = -1;
		int tgtChannelInt = -1;
		int swmateChannelInt = -1;

		// Convert the channel numbers into ints
		try {
			srcChannelInt = Integer.parseInt(sourceChannel);
			tgtChannelInt = Integer.parseInt(targetChannel);
		}
		catch (Exception e) {
			log.error("Exception parsing channel numbers", e);
		}

		if (srcChannelInt == -1 || tgtChannelInt == -1) {
			log.error("processEvent::connection event::Invalid source or target channel.");
			log.debug("processEvent::connection event::srcChannelInt: "
			    + srcChannelInt + " tgtChannelInt: " + tgtChannelInt);
			return;
		}

		LpcpFacility sourceFac = getModelMgr().getFacility(neId, sourceAid);
		LpcpFacility targetFac = getModelMgr().getFacility(neId, targetAid);
		LpcpFacility swmateFac = null;

		if (sourceFac == null || targetFac == null) {
			log.error("processEvent::Could not find source or target facility.  sourceFac: "
			    + sourceFac + " targetFac: " + targetFac);
			return;
		}

		Map<String, String> xconnMap = new HashMap<String, String>();

		xconnMap.put(CrossConnection.SOURCE_NEID, neId);
		xconnMap.put(CrossConnection.TARGET_NEID, neId);
		xconnMap.put(CrossConnection.SOURCE_PORT_AID, sourceAid);
		xconnMap.put(CrossConnection.TARGET_PORT_AID, targetAid);
		xconnMap.put(CrossConnection.RATE, rate);
		xconnMap.put(CrossConnection.SOURCE_CHANNEL, sourceChannel);
		xconnMap.put(CrossConnection.TARGET_CHANNEL, targetChannel);
		xconnMap.put(CrossConnection.CKTID, cktid);

		// SWMATE handling
		if (swmateXcAid != null && !"N/A".equals(swmateXcAid)) {
			swmateAid = swmateXcAid.substring(0, swmateXcAid.lastIndexOf('-'));
			swmateChannel = swmateXcAid.substring(swmateXcAid.lastIndexOf('-') + 1,
			    swmateXcAid.length());
			try {
				swmateChannelInt = Integer.parseInt(swmateChannel);
			}
			catch (Exception e) {
				log.error("processEvent::connection event::Invalid swmate channel.");
				log.debug("processEvent::connection event::swmateChannelInt: "
				    + swmateChannelInt);
				return;
			}

			swmateFac = getModelMgr().getFacility(neId, swmateAid);

			if (swmateFac == null) {
				log.error("processEvent::Could not find swmate facility: "
				    + swmateFac);
				return;
			}

			xconnMap.put(CrossConnection.SWMATE_NEID, neId);
			xconnMap.put(CrossConnection.SWMATE_PORT_AID, swmateAid);
			xconnMap.put(CrossConnection.SWMATE_CHANNEL, swmateChannel);
		}

		CrossConnection xconn = new CrossConnection(xconnMap);
		boolean isDRACxcon = xconn.isDracConnection();

		if (OperationType.OPERATION_ADD.toString().equals(operation)) {
			if (!isDRACxcon) {

				synchronized (getModelMgr()) {
					sourceFac.getTracker().takeBandwidth(xconn);
					targetFac.getTracker().takeBandwidth(xconn);
					if (swmateFac != null) {
						swmateFac.getTracker().takeBandwidth(xconn);
					}
				}
			}
			else {
				log.debug("Skipped processing of ADD event for OpenDRAC xcon: " + cktid);
			}
		}
		else if (OperationType.OPERATION_DELETE.toString().equals(operation)) {
			if (!isDRACxcon) {


				synchronized (getModelMgr()) {
					sourceFac.getTracker().giveBandwidth(xconn);
					targetFac.getTracker().giveBandwidth(xconn);
					if (swmateFac != null) {
						swmateFac.getTracker().giveBandwidth(xconn);
					}
				}
			}
			else {
				log.debug("Skipped processing of DELETE event for OpenDRAC xcon: " + cktid);
			}
		}
	}

	private void processDBChangeEvent(Element element) throws Exception {
		XMLOutputter xmlOut = new XMLOutputter();
		String operation = null;
		String OP_ADD_KEY = "add";
		String OP_DEL_KEY = "delete";
		String OP_KEY = "operation";


		// Detected dbchange event
		// Expected format of incoming XML:
		// <NetworkElementEvent>
		// <event name="dbchange" id="00-20-D8-DF-33-8B_10_0003302"
		// time="1144272290616">
		// <data>
		// <element name="description" value="AUTO_STCHG" />
		// <element name="aid" value="ETH-1-1-1" />
		// <element name="state" value="OOS-AU" />
		// </data>
		// <eventInfo notificationType="STCHG-ETH" occurredDate="06-04-05"
		// occurredTime="21-26-29" />
		// <node type="OME" id="00-20-D8-DF-33-8B" ip="47.128.38.252" port="10001"
		// tid="Asd001A_OME1T"
		// mode="SDH" status="N/A" />
		// </event>
		// <backslashNetworkElementEvent>
		//
		// We are only interested in the <data></data> and <node></node> blocks
		Element tempElement = null;
		Map<String, String> dbchangeDetails = new HashMap<String, String>();
		String notificationType = null;
		String neId = null;
		String aid = null;
		// String state = null;

		if (element.getChild(DATA_ATTR) != null) {
			@SuppressWarnings("unchecked")
      List<Element> elements = element.getChild(DATA_NODE).getChildren(
			    ELEMENT_NODE);

			for (int i = 0; i < elements.size(); i++) {
				tempElement = elements.get(i);
				if (dbchangeDetails.get(tempElement.getAttributeValue(NAME_ATTR)) != null) {
					// HACK... currently, the xcon event will include two rate attributes.
					// One with the old
					// value and one with the new.
					// We can't overwrite the old value in the MAP since we need it in
					// order to reclaim the
					// right amount of bandwidth
					if ("rate".equals(tempElement.getAttributeValue(NAME_ATTR))
					    && "NONE".equals(tempElement.getAttributeValue(VALUE_ATTR))) {
						log.debug("XCON DEL EVENT HACK activated... not overwriting existing rate");
						continue;
					}
				}
				dbchangeDetails.put(tempElement.getAttributeValue(NAME_ATTR),
				    tempElement.getAttributeValue(VALUE_ATTR));
			}


		}
		if (element.getChild(NODE_NAME) != null) {
			tempElement = element.getChild(NODE_NAME);

			neId = tempElement.getAttributeValue(NEID_ATTR);
		}
		if (element.getChild(EVENTINFO_NODE) != null) {
			tempElement = element.getChild(EVENTINFO_NODE);
			notificationType = tempElement.getAttributeValue(NOTIFTYPE_ATTR);
		}

		// Connection event
		if (EVTNOTIF_XCON.equals(notificationType)) {
			try {
				processConnectionEvent(neId, dbchangeDetails);
			}
			catch (Exception e) {
				log.error(
				    "Failed to update trackers on receipt of a connection event event :"
				        + xmlOut.outputString(element), e);
			}
		}
		else if (EVTNOTIF_FAC.equals(notificationType)) {
			aid = dbchangeDetails.get(AID_ATTR);

			log.debug("Detected facility notification event: " + aid);

			// Fetch the facility from the model
			LpcpFacility existingFacility = getModelMgr().getFacility(neId, aid);
			operation = dbchangeDetails.get(OP_KEY);

			if (existingFacility == null) {
				/** We don't have this facility in memory */
				if (OP_ADD_KEY.equals(operation)) {
					log.debug("Detected add facility event");
					getModelMgr().parseAndAddToModel(dbchangeDetails, neId);
				}
				else {
					log.error("Error, could not find facility corresponding to neid: "
					    + neId + " aid: " + aid + " in model!");
				}
			}
			else {
				if (OP_DEL_KEY.equals(operation)) {
					// Remove facility from model
					log.debug("Detected delete facility event");
					synchronized (getModelMgr()) {
						getModelMgr().removeFacilityFromModel(neId,
						    dbchangeDetails.get("aid"));
					}
				}
				else {
					/** Facility DB Change */

					existingFacility.setState(dbchangeDetails.get(STATE_ATTR));

					for (String key : dbchangeDetails.keySet()) {
						// Change the value of VCAT
						if (FacilityConstants.VCAT_ATTR.equals(key)) {
							existingFacility.setVCATAttr(dbchangeDetails.get(key));

						}
						else if (FacilityConstants.RATE_ATTR.equals(key)) {
							existingFacility.setRate(dbchangeDetails.get(key));
						}
					}
				}
			}
		}
		else if (EVTNOTIF_ADJ.equals(notificationType)) {
			/*
			 * GG ADJ This is the only location in Lpcp in which we will be notified
			 * of ADJ adds/deletes.
			 */
			TopologyManager.INSTANCE.requestConsolidation();
		}
		else if (EVTNOTIF_DOC.equalsIgnoreCase(notificationType)) {
			notifyClientsDocEvent(element);
		}
	}

	/**
	 * processEvent - handle network element events (association, dbchange etc)
	 * <p>
	 * <bold>WARNING</bold>: If any TL1 commands need to be sent out to the proxy
	 * from anywhere within this method call or any methods called from this
	 * method, the TL1 command MUST be encapsulated in a thread. Otherwise, the
	 * TL1 client will hang and this method will never return.
	 * <p>
	 * <bold>NOTE</bold>: This method is not synchronized because it is currently
	 * only ever called from one place (handleCallback). The method handleCallback
	 * is synchronized and so processEvent is indirectly thread safe. If this
	 * method is ever called from elsewhere, it will need to be synchronized.
	 *
	 * @param event
	 *          - HashMap containing the event received from the proxy
	 */
	private void processEvent(Map<String, Object> event) throws Exception {
		String eventXML = (String) event.get("EVENT");


		if (eventXML == null) {
			log.error("Received corrupted event: event is null " + event);
			return;
		}

		GenericJdomParser jparser = new GenericJdomParser();
		jparser.parse(eventXML);
		Element root = jparser.getRoot();
		if (root == null) {
			log.error("Received corrupted event: event is null " + event);
			return;
		}

		// Check if it's a NetworkElementEvent
		log.debug("Event:"
		    + new XMLOutputter(Format.getPrettyFormat()).outputString(root));

		if (NE_EVENT_NAME.equals(root.getName())) {
			/* Detected a Network Element AO */
			if (root.getChild(EVENT_NAME) != null) {
				Element element = root.getChild(EVENT_NAME);
				if (EVT_ASSOCIATION.equals(element.getAttributeValue(NAME_ATTR))) {
					// Notify clients of the event
					notifyClientsVertexUpdated(event, root);
					element = root.getChild(EVENT_NAME).getChild(NODE_NAME);
					processAssociationEvent(element);
				}
				else if (EVT_DBCHANGE.equals(element.getAttributeValue(NAME_ATTR))) {
					processDBChangeEvent(element);
				}
				else {

				}
			}
			else {

			}
		}
	}
}
